<html>
    <head>
    </head>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css"/>
        <title>sdf-glyph-tool</title>
        <script src="https://unpkg.com/vue@3"></script>
        <script src="https://unpkg.com/jszip@3.1.5/dist/jszip.min.js"></script>
        <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
        <script src="https://unpkg.com/pbf@3.2.1/dist/pbf.js"></script>
        <script src="glyphs.js"></script>
        <style>
            .wrapper {
                width: 500px;
            }
            
            .progress-bar {
                width: 100%;
                background-color: #e0e0e0;
                padding: 3px;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, .2);
            }
            
            .progress-bar-fill {
                display: block;
                height: 22px;
                background-color: #659cef;
                transition: width 500ms ease-in-out;
            }
        </style>
    </head>
    <body>
        <div class="sans-serif bg-black flex vh-100" id="app">

        </div>
        <script>
            var worker = new Worker('worker.js');

            function pbfToCanvas(buffer,canv) {
                var pbf = new Pbf(buffer);
                var g = glyphs.read(pbf);

                let foo = g.stacks[0].glyphs;
                let max_height = 0;
                let rows = 1;
                let current_x = 0;
                for (var g of foo) {
                    if (g.height > max_height) {
                        max_height = g.height;
                    }
                    current_x = current_x + g.width + 6;
                    if (current_x > 800) {
                        current_x = 0;
                        rows++;
                    }
                }
                canv.height = (max_height + 6) * rows;
                canv.width = 800;
                var ctx = canv.getContext('2d');

                var xval = 0;
                var yval = 0;
                for (var g of foo) {
                    if (!g.bitmap) continue;
                    const img = new Uint8ClampedArray((g.height+6) * (g.width+6) * 4);
                    for (var i = 0; i < (g.height + 6) * (g.width+6); i++) {
                        img[i*4] = 255;
                        img[i*4+1] = 255;
                        img[i*4+2] = 255;
                        img[i * 4 + 3] = g.bitmap[i];
                    }
                    if (xval + g.width + 6 > 800) {
                        xval = 0;
                        yval += (max_height + 6);
                    }
                    xval += g.width+6;
                    ctx.putImageData(new ImageData(img,g.width+6),xval,yval)
                }
                return canv;
            }


            let app = Vue.createApp({
            data() {
                return {
                    rendered: [],
                    inProgress: false
                }
            },
            components: {
                'GlyphRange':
                {
                    props: ['name','buffer'],
                    template: `
                        <div>
                        {{ name }}
                        <canvas ref="canvas"/>
                        </div>
                    `,
                    mounted() {
                        let canvas = pbfToCanvas(this.buffer,this.$refs.canvas);
                    } 
                }
            },
            template: `
                <div class="w-25-l w-50 vh-100 bg-light-gray pa4">
                    <h1>SDF Glyph Tool</h1>
                    <div class="bg-light-blue pa2 dim pointer" v-on:click="load_example">Load Example (NotoSans-Regular.ttf)</div>
                    <input class="mt3" type="file" v-on:change="add_font"/>
                    <div class="mt4" v-if="inProgress">Rendering in progress...</div> 
                    <div class="progress-bar mt2">
                        <span class="progress-bar-fill" :style="{ width: pctDone + '%' }"></span>
                    </div>
                    <div v-if="done" class="bg-blue mt3 pa2 dim pointer" v-on:click="download_zip">Download</div>
                    <div class="mt4"><a href="https://github.com/protomaps/sdf-glyph-tool">On GitHub</a></div>
                </div>
                <div class="w-75-l w-50 overflow-y-scroll white flex flex-column items-center">
                    <GlyphRange v-for="file in rendered" :name="file.name" :buffer="file.buffer"/>
                </div>
            `,
            methods: {
                add_font(event) {
                    const file_reader = new FileReader();
                    file_reader.onload = function(event) {
                        const uint8Arr = new Uint8Array(event.target.result);
                        app.inProgress = true;
                        worker.postMessage(uint8Arr, [uint8Arr.buffer]);
                    }
                    this.fontName = event.target.files[0].name.slice(0,-4)
                    file_reader.readAsArrayBuffer(event.target.files[0]);
                },
                download_zip(event) {
                    let fontName = this.fontName;
                    var zip = new JSZip();
                    var folder = zip.folder(fontName);
                    for (var i of this.rendered) {
                        folder.file(i.name, i.buffer);
                    }
                    zip.generateAsync({type:"blob"})
                    .then(function(content) {
                        saveAs(content, fontName + ".zip");
                    }); 
                },
                load_example() {
                    this.fontName = "NotoSans-Regular";
                    fetch('examples/NotoSans-Regular.ttf').then(resp => {
                        return resp.arrayBuffer();
                    }).then(buffer => {
                        const uint8Arr = new Uint8Array(buffer);
                        app.inProgress = true;
                        worker.postMessage(uint8Arr, [uint8Arr.buffer]);
                    });
                }
            },
            computed: {
                pctDone() {
                    return this.rendered.length / 256 * 100;
                },
                done() {
                    return this.rendered.length === 256;
                }
            }
            }).mount('#app')

            worker.onmessage = function (e) {
                let i = e.data.index;
                app.rendered.push({
                    buffer:e.data.buffer,
                    name:i + "-" + (i + 255) + ".pbf"
                })
                if (app.rendered.length === 256) {
                    app.inProgress = false;
                }
            };
        </script>
    </body>
</html>